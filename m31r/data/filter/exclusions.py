# Author : Eshan Roy <eshanized@proton.me>
# SPDX-License-Identifier: MIT

"""
Directory and file exclusion rules.

These encode the data architecture spec sections ยง9 and ยง10 directly.
The spec says certain directories (target/, vendor/, .git/, etc.) and
file types (binaries, images, lock files) are pure noise for training
and must be dropped unconditionally.
"""

from pathlib import PurePosixPath

EXCLUDED_DIRECTORY_NAMES: frozenset[str] = frozenset(
    {
        "target",
        "vendor",
        "node_modules",
        "build",
        "dist",
        "generated",
        ".git",
        ".github",
        ".hg",
        ".svn",
        "__pycache__",
    }
)

EXCLUDED_FILE_EXTENSIONS: frozenset[str] = frozenset(
    {
        ".exe",
        ".dll",
        ".so",
        ".dylib",
        ".o",
        ".a",
        ".png",
        ".jpg",
        ".jpeg",
        ".gif",
        ".bmp",
        ".ico",
        ".svg",
        ".zip",
        ".tar",
        ".gz",
        ".bz2",
        ".xz",
        ".7z",
        ".pdf",
        ".doc",
        ".docx",
        ".lock",
        ".min.js",
        ".min.css",
        ".wasm",
        ".pyc",
        ".class",
    }
)


def should_exclude_path(file_path: PurePosixPath, excluded_dirs: list[str]) -> bool:
    """
    Decide whether a file should be dropped based on its path.

    We check two things:
    1. Is any directory component in the exclusion set?
       e.g. "some_crate/target/debug/main.rs" gets dropped because "target" is excluded
    2. Does the file extension match a known binary/noise type?

    The excluded_dirs parameter lets the config override the defaults,
    so you can customize what gets filtered per run.
    """
    parts = file_path.parts

    excluded_set = frozenset(excluded_dirs) | EXCLUDED_DIRECTORY_NAMES
    for part in parts[:-1]:
        if part in excluded_set:
            return True

    suffix = file_path.suffix.lower()
    if suffix in EXCLUDED_FILE_EXTENSIONS:
        return True

    return False


def exceeds_size_limits(
    content: str,
    max_bytes: int,
    max_lines: int,
) -> bool:
    """
    Check if file content exceeds the size thresholds from the spec.

    Large files tend to be autogenerated (think protobuf bindings, fuzz corpuses)
    and add noise without much signal. The spec sets 5 MB / 5000 lines as the
    cutoff, but both values come from config so they can be tuned.
    """
    if len(content.encode("utf-8")) > max_bytes:
        return True
    if content.count("\n") + 1 > max_lines:
        return True
    return False
